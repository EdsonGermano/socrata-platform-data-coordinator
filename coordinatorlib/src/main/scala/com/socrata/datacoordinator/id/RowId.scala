package com.socrata.datacoordinator.id

import com.rojoma.json.codec.JsonCodec
import com.rojoma.json.ast.{JString, JValue, JNumber}

trait RowId {
  val numeric: Long
  val obfuscated: String

  final override val hashCode = numeric.hashCode ^ 0x85497235
  final override def equals(o: Any) = o match {
    case that: RowId =>
      this.numeric == that.numeric
    case _ =>
      false
  }
}

class NumericRowId(val numeric: Long, obfuscator: Long => String) extends RowId {
  lazy val obfuscated = obfuscator(numeric)
}

class ObfuscatedRowId(val obfuscated: String, deobfuscator: String => Long) extends RowId {
  lazy val numeric = deobfuscator(obfuscated)
}

class BothRowId(val numeric: Long, val obfuscated: String) extends RowId

/**
 * @param obfuscator Turns a number into a string.  If out of range, it must return some value which
 *                   will never be generated by a valid input.
 * @param deobfuscator Turns a string into a number.  If out of range, it must return some value which
 *                     will never be generated by a valid input.
 */
class RowIdProcessor(initialNumeric: Long, obfuscator: Long => String, deobfuscator: String => Long) {
  def apply(x: Long): RowId = new NumericRowId(x, obfuscator)
  def apply(x: String): RowId = new ObfuscatedRowId(x, deobfuscator)
  def apply(x: Long, y: String): RowId = new BothRowId(x, y)
  val initial: RowId = new BothRowId(initialNumeric, obfuscator(initialNumeric))

  val nonObfusactedCodec = new JsonCodec[RowId] {
    def encode(x: RowId) = JNumber(x.numeric)
    def decode(v: JValue) = v match {
      case JNumber(n) => Some(apply(n.toLong))
      case _ => None
    }
  }

  val obfusactedCodec = new JsonCodec[RowId] {
    def encode(x: RowId) = JString(x.obfuscated)
    def decode(v: JValue) = v match {
      case JString(s) => Some(apply(s))
      case _ => None
    }
  }
}

object RowId {
  implicit val ordering = new Ordering[RowId] {
    def compare(x: RowId, y: RowId): Int = Ordering.Long.compare(x.numeric, y.numeric)
  }
}
